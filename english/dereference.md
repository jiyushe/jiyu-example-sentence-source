# dereference

Please help us improve the quality of example sentences! [Edit on Github](https://github.com/jiyushe/jiyu-example-sentence-source/blob/main/english/dereference.md)

<p><span class="chinese">那么，解除对应x的指针数据的,索引箭头。</span><span class="english">So, doing a dereference on x follows the arrow to access its pointee.</span></p>

<p><span class="chinese">如果没有使用解引用操作，则修改的是指针本身的值。</span><span class="english">If there is no dereference , then the pointer itself is being changed.</span></p>

<p><span class="chinese">与下标和解引用操作符一样，赋值操作也返回左值。</span><span class="english">Like the subscript and dereference operators, assignment returns an lvalue.</span></p>

<p><span class="chinese">解引用操作符的优先级比加法操作符高。</span><span class="english">The dereference operator has a higher precedence than the addition operator.</span></p>

<p><span class="chinese">好的，我废除这个指针,在指针数据中存储数字。</span><span class="english">Okay. I'll dereference the pointer x 42 to store the number 42 into its pointee.</span></p>

<p><span class="chinese">对解引用操作的结果赋值是赋一个新值到相应的元素。</span><span class="english">Assigning to the result of a dereference assigns a new value to the indexed element.</span></p>

<p><span class="chinese">由于加法操作和解引用操作的优先级不同，上述表达式中的圆括号是必要的。</span><span class="english">The parentheses are required due to the precedence of the addition and dereference operators.</span></p>

<p><span class="chinese">因此，在对未初始化的指针进行解引用时，通常会导致程序崩溃。</span><span class="english">Doing so usually leads to a crash as soon as we attempt to dereference the uninitialized pointer.</span></p>

<p><span class="chinese">迭代器类型定义了解引用操作符来返回迭代器所指向的对象。</span><span class="english">The iterator types define the dereference operator to return the object to which the iterator refers.</span></p>

<p><span class="chinese">解引用返回左值，因此可将解引用操作符用作赋值操作的左操作数。</span><span class="english">Dereference returns an lvalue, so we may use a dereference operator as the left-hand operand of an assignment.</span></p>

<p><span class="chinese">用抛出表达式抛出静态类型时，比较麻烦的一种情况是，在抛出中对指针解引用。</span><span class="english">The one case where it matters that a throw expression throws the static type is if we dereference a pointer in a throw.</span></p>

<p><span class="chinese">指定您的结构和结构之内的列表变量，后者用于在内部取消引用，返回容器。</span><span class="english">Specify your structure and the list variable within your structure, which is used internally to dereference back to the container.</span></p>

<p><span class="chinese">你，作为一个程序员，将解除引用的指针，并期待在该节点上的数据，可能会改变它或用它做什么。</span><span class="english">You, as a programmer, would dereference that pointer and look at the data in that node, perhaps change it or do something with it.</span></p>

<p><span class="chinese">所有迭代器都支持自增操作符，从一个元素定位下一个元素，并提供解引用操作符访问元素的值。</span><span class="english">All iterators support the increment operator to navigate from one element to the next, and the dereference operator to access the element value.</span></p>

<p><span class="chinese">换句话说，不要提取一个用户模式应用提供的地址，并且把那个地址看成一个我们可以直接废弃的指示器。</span><span class="english">In other words, don't take an address that a user-mode application provides and treat that address as a pointer that we can directly dereference.</span></p>

<p><span class="chinese">同原子一样，你可以对引用取值。例子里袜子的顺序可能与你的不一样，因为使用的是无序集合。</span><span class="english">You can dereference refs just like you can dereference atoms. In this example, the order of your socks will probably be different because we're using an unordered set.</span></p>

<p><span class="chinese">此警告意味着取消引用指针所带来的后果被忽略，这会产生一个问题，那就是为何在第一个位置取消引用指针。</span><span class="english">This warning indicates that the result of a pointer dereference is being ignored, which raises the question of why the pointer is being dereferenced in the first place.</span></p>

<p><span class="chinese">通过指针映射集和故障模型，可以自动检测内存释放异常、内存泄露和空指针引用等动态内存故障，提高了测试效率。</span><span class="english">Through pointer mapping sets and fault model, it can detect bad deallocation, memory leak and null pointer dereference faults automatically and increase the testing efficiency.</span></p>

<p><span class="chinese">不管「未来」到达与否，开发者为了一个损坏的指针不断的遍历内存，多少是有些愚蠢的事情了。</span><span class="english">"The future" or not, it's getting a bit silly for GUI application developers to perpetually be one bad pointer dereference away from scribbling all over their application's memory.</span></p>

