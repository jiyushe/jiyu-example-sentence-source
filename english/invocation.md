# invocation

<p><span class="chinese">简化Varargs方法调用。</span><span class="english">Simplified Varargs Method Invocation.</span></p>

<p><span class="chinese">按名称的动态子流程调用</span><span class="english">Dynamic invocation of subprocesses by name</span></p>

<p><span class="chinese">我们会集中研究开头的那段祷文。</span><span class="english">You will focus, however, on the opening invocation.</span></p>

<p><span class="chinese">进行两次这样的调用，并观察输出控制台。</span><span class="english">Do this invocation twice and watch the output console.</span></p>

<p><span class="chinese">这种调用基本上是无人值守和同步的。</span><span class="english">The invocation is basically unattended and synchronous.</span></p>

<p><span class="chinese">协作任务和调用任务均受支持。</span><span class="english">Both collaboration tasks and invocation tasks are supported.</span></p>

<p><span class="chinese">这个模型提供了一个非常巧妙的方法调用过程。</span><span class="english">This model provides a much neater method invocation process.</span></p>

<p><span class="chinese">Indigo支持2种主要的服务调用方式</span><span class="english">Indigo supports two major approaches to the service invocation</span></p>

<p><span class="chinese">对于实际服务调用，这些存根使用缺省端口。</span><span class="english">These stubs use a default port for the actual service invocation.</span></p>

<p><span class="chinese">你援用这样或那样权利对你一点好处都没有。</span><span class="english">Your invocation of some right or other will do you no good at all.</span></p>

<p><span class="chinese">技术的重点是匹配接口和调用协议。</span><span class="english">Technology focuses on matching interfaces and invocation protocols.</span></p>

<p><span class="chinese">请求-响应样式——由客户机服务进行同步调用。</span><span class="english">Request-response style -- synchronous invocation by client services.</span></p>

<p><span class="chinese">也可以重新启用“编辑并继续”的自动调用。</span><span class="english">You can also re-enable the automatic invocation of Edit and Continue.</span></p>

<p><span class="chinese">要考虑的另一方面是调用服务的变数。</span><span class="english">Another dimension to consider is how variable the service invocation is.</span></p>

<p><span class="chinese">然而，为了服务调用它可能还支持其他的协议。</span><span class="english">However, it is possible to support other protocols for service invocation.</span></p>

<p><span class="chinese">注意远程调用是如何在自己的执行线程中执行的。</span><span class="english">Note how the remote invocation was performed in its own thread of execution.</span></p>

<p><span class="chinese">运行时的通知调用开销，需要决定切入点匹配。</span><span class="english">Advice invocation overhead at run time, needed to determine pointcut matching</span></p>

<p><span class="chinese">一个方法调用意味着信息从召集者传向被召集者。</span><span class="english">A method invocation is represented by a message sent from a caller to a callee.</span></p>

<p><span class="chinese">这样我们就不必在每次调用例程时都拼写出模式名。</span><span class="english">This way we donâ ™t have to spell the schema name out for each routine invocation.</span></p>

<p><span class="chinese">正如前面提到的，源组件确定将使用哪种类型的调用。</span><span class="english">As mentioned, the source component determines what type of invocation will be used.</span></p>

