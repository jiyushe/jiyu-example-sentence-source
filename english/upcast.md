# upcast

<p><span class="chinese">学生眼睛朝上看着他的老师。</span><span class="english">The student looked at his teacher with upcast eyes.</span></p>

<p><span class="chinese">一旦把一个对象上溯给一个接口类型，只有该接口中指定的成员才可以被使用。</span><span class="english">Once an object has been upcast to an interface type, only the members specified in the interface can be used.</span></p>

<p><span class="chinese">在使用向上转换运算符时，编译器会尝试根据上下文来推断出要转换为的类型。</span><span class="english">When you use the upcast operator, the compiler attempts to infer the type you are converting to from the context.</span></p>

<p><span class="chinese">仿真模型中，砧座的运动被分为振动及上抛运动两个阶段。</span><span class="english">In this simulation model, the motion of the anvil was divided into the vibration phase and the upcast motion phase.</span></p>

<p><span class="chinese">对于向上转换运算符，如果编译器无法根据上下文推断出特定的目标类型，则将报告错误。</span><span class="english">As for the upcast operator, if the compiler cannot infer a specific target type from the context, it reports an error.</span></p>

<p><span class="chinese">继承一个基类而无法将它向下或向上转换到基类的理念是不明智的。</span><span class="english">The idea of inheriting from a base class without being able to downcast to it or upcast to the base just seemed silly.</span></p>

<p><span class="chinese">当你上溯到基接口时，你只可以访问由那个接口所指定的成员，就像上溯到基类那样。</span><span class="english">When you upcast to a base interface, you can only access the members specified by that interface, just as for upcasting to base classes.</span></p>

<p><span class="chinese">当一个类已经实现了一个接口时，从这个类生成的对象可以上溯到这个接口类型，如清单12-3所示。</span><span class="english">When a class has implemented an interface, objects created from that class can be upcast to the interface type, as demonstrated by Listing 12-3.</span></p>

<p><span class="chinese">1月14日，巨人网络集团有限公司总裁刘伟女士在中国游戏产业年会上抛出“赢在巨人”计划。</span><span class="english">On January 14, president of limited company of giant network group Ms. Liu Wei is in China upcast of game industry annual meeting goes out " win in giant " plan.</span></p>

<p><span class="chinese">你只需要将对象上传转化为基类对象不需要知道额外的信息，而这些都是通过多态实现的。</span><span class="english">All you need to do is upcast from the derived class and never look back to see what exact type of object you're dealing with. Everything is handled through polymorphism.</span></p>

<p><span class="chinese">由于所有位于对象池中的对象都被上溯到它们的基类型，方法多态使得只有在运行时刻才能真正确定到底哪个对象的方法被执行。</span><span class="english">Since all objects in the class pool are upcast to their common base class, the polymorphism of the method leads to that which object method will be executed can only be ascertained at runtime.</span></p>

